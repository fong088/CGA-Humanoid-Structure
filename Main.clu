DefVarsN3();

scale = 0.004;  		// Scale of the entire body

HEAD = 150 * scale;			// NECK TO HEAD
BACK = 330.4 * scale;		// LLJ_LNJ
SHOULDER = 176.3 * scale;  	// LNJ_SJ
ARM = 239.3 * scale;  		// SJ_EJ
FOREARM = 250 * scale;		// EJ_HJ
GROIN = 119.5 * scale;		// LLJ_HJ Vertical
WAIST = 211.6 * scale;		// LLJ_HJ Horizontal
KNEE = 380.6 * scale;		// HJ_KJ
AUX_KNEE = 21.2 * scale;
SHIN = 358.6 * scale;		// KJ_AJ
AUX_SHIN = 3.7 *scale;
JOINT_RADIUS = 20 * scale;
CILINDER_RADIUS = JOINT_RADIUS / 2;

Cilindro =
{
	A = _P(1);//Entrada 1 (Punto Inicial de Cilindro)
	B = _P(2);//Entrada 2 (Punto Final de Cilindro)
	r = _P(3);//Entrada 3 (Radio del cilindro)
	
	E = einf^e0; //Plano de Minkowski
	Ae = (A^E)*E; // Quitar parte "conformal" a Punto "A"
	Be = (B^E)*E; // Quitar parte "conformal" a Punto "B"
	Ce = Be - Ae; // Vector de dirección en Euclidiano que va de "A" a "B"
 	C = Ce + 1/2*Ce^^2*einf + e0; //Vector "Ce" en conformal
	DrawCylinder(A,C,r);
	[C,Ce,"Hola"] // Salida(s)
}
Cajita=
{
	C = _P(1);//Entrada 1 (Punto Centro de Caja)
	X = _P(2);//Entrada 2 (Punto direccion 1)
	Y = _P(3);//Entrada 3 (Punto direccion 2)
	Z = _P(4); // Entrada 4 (Punto direccion 3)
	
	E = einf^e0; //Plano de Minkowski
	D1e = ((X-C)^E)*E; 
	D2e = ((Y-C)^E)*E; 
	D3e = ((Z-C)^E)*E; 	
	D1 = D1e + 1/2*D1e^^2*einf + e0; 
	D2 = D2e + 1/2*D2e^^2*einf + e0; 
	D3 = D3e + 1/2*D3e^^2*einf + e0; 
	DrawBox(C,D1,D2,D3);
}

globalX = Slider("Global X",-5,5,0.1,0); // Sliders para traslación global
globalY = Slider("Global Y",-5,5,0.1,0);
globalZ = Slider("Global Z",-5,5,0.1,0);
globalRx = Slider("Global RX",-Pi,Pi,0.1,0);// Sliders para rotación c.r.a. MR Local
globalRy = Slider("Global RY",-Pi,Pi,0.1,0);
globalRz = Slider("Global RZ",-Pi,Pi,0.1,0);

M_GLOBAL = TranslatorN3(globalX,globalY,globalZ)*RotorN3(1,0,0,globalRx)*RotorN3(0,1,0,globalRy)*RotorN3(0,0,1,globalRz); // Motor Global

:IPNS;
O = M_GLOBAL*e0*(~M_GLOBAL) ;// Punto inicial (origen)

//LLJ
LLJ_xr = Slider("LLJ xr",-Pi,Pi,0.1,0);
LLJ_zr = Slider("LLJ zr",-Pi,Pi,0.1,0);
R_LLJ = RotorN3(1,0,0,LLJ_xr)*RotorN3(0,0,1,LLJ_zr);
M_LLJ = R_LLJ;
MLLJ = M_GLOBAL*M_LLJ;
P_LLJ = MLLJ*e0*(~MLLJ);

//UPPER

//UPPER_AUX
T_UAUX = TranslatorN3(0,BACK,0);
M_UAUX = T_UAUX; // Primer motor
M_UAUX = MLLJ*M_UAUX; //motor auxiliar ("acumulado")
P_UAUX = M_UAUX*e0*(~M_UAUX);

//LNJ
LNJ_xr = Slider("LNJ xr",-Pi,Pi,0.1,0);
LNJ_yr = Slider("LNJ yr",-Pi,Pi,0.1,0);
T_LNJ = TranslatorN3(0,HEAD,0);
R_LNJ = RotorN3(1,0,0,LNJ_xr)*RotorN3(0,1,0,LNJ_yr);
M_LNJ = T_LNJ*R_LNJ;
MLNJ = M_UAUX*M_LNJ;
P_LNJ = MLNJ*e0*(~MLNJ);

//SJR
SJR_xr = Slider("SJR xr",-Pi,Pi,0.1,0);
SJR_yr = Slider("SJR yr",-Pi,Pi,0.1,0);
SJR_zr = Slider("SJR zr",-Pi,Pi,0.1,0);
T_SJR = TranslatorN3(-SHOULDER, 0,0);
R_SJR = RotorN3(1,0,0,SJR_xr)*RotorN3(0,1,0,SJR_yr)*RotorN3(0,0,1,SJR_zr);
M_SJR = T_SJR*R_SJR;
MSJR = M_UAUX*M_SJR;
P_SJR = MSJR*e0*(~MSJR);

//SJL
SJL_xr = Slider("SJL xr",-Pi,Pi,0.1,0);
SJL_yr = Slider("SJL yr",-Pi,Pi,0.1,0);
SJL_zr = Slider("SJL zr",-Pi,Pi,0.1,0);
T_SJL = TranslatorN3(SHOULDER, 0,0);
R_SJL = RotorN3(1,0,0,SJL_xr)*RotorN3(0,1,0,SJL_yr)*RotorN3(0,0,1,SJL_zr);
M_SJL = T_SJL*R_SJL;
MSJL = M_UAUX*M_SJL;
P_SJL = MSJL*e0*(~MSJL);

//EJR
EJR_xr = Slider("EJR xr",-Pi,Pi,0.1,0);
T_EJR = TranslatorN3(0, -ARM,0);
R_EJR = RotorN3(1,0,0,EJR_xr);
M_EJR = T_EJR*R_EJR;
MEJR = MSJR*M_EJR;
P_EJR = MEJR*e0*(~MEJR);

//EJL
EJL_xr = Slider("EJL xr",-Pi,Pi,0.1,0);
T_EJL = TranslatorN3(0, -ARM,0);
R_EJL = RotorN3(1,0,0,EJL_xr);
M_EJL = T_EJL*R_EJL;
MEJL = MSJL*M_EJL;
P_EJL = MEJL*e0*(~MEJL);

//WR
T_WR = TranslatorN3(0,-FOREARM,0);
M_WR = T_WR;
MWR = MEJR*M_WR;
P_WR = MWR*e0*(~MWR);

//WL
T_WL = TranslatorN3(0,-FOREARM,0);
M_WL = T_WL;
MWL = MEJL*M_WL;
P_WL = MWL*e0*(~MWL);

//LOWER

//LAUX
T_LAUX = TranslatorN3(0,-GROIN,0);
M_LAUX = T_LAUX;
MLAUX = MLLJ*M_LAUX;
P_LAUX = MLAUX*e0*(~MLAUX);

//HJR
HJR_xr = Slider("HJR xr",-Pi,Pi,0.1,0);
HJR_yr = Slider("HJR yr",-Pi,Pi,0.1,0);
HJR_zr = Slider("HJR zr",-Pi,Pi,0.1,0);
T_HJR = TranslatorN3(-(WAIST/2), 0,0);
R_HJR = RotorN3(1,0,0,HJR_xr)*RotorN3(0,1,0,HJR_yr)*RotorN3(0,0,1,HJR_zr);
M_HJR = T_HJR*R_HJR;
MHJR = MLAUX*M_HJR;
P_HJR = MHJR*e0*(~MHJR);

//HJL
HJL_xr = Slider("HJL xr",-Pi,Pi,0.1,0);
HJL_yr = Slider("HJL yr",-Pi,Pi,0.1,0);
HJL_zr = Slider("HJL zr",-Pi,Pi,0.1,0);
T_HJL = TranslatorN3((WAIST/2), 0,0);
R_HJL = RotorN3(1,0,0,HJL_xr)*RotorN3(0,1,0,HJL_yr)*RotorN3(0,0,1,HJL_zr);
M_HJL = T_HJL*R_HJL;
MHJL = MLAUX*M_HJL;
P_HJL = MHJL*e0*(~MHJL);

//KJR
KJR_xr = Slider("KJR xr",-Pi,Pi,0.1,0);
T_KJR = TranslatorN3(-AUX_KNEE, -KNEE,0);
R_KJR = RotorN3(1,0,0,KJR_xr);
M_KJR = T_KJR*R_KJR;
MKJR = MHJR*M_KJR;
P_KJR = MKJR*e0*(~MKJR);

//KJL
KJL_xr = Slider("KJL xr",-Pi,Pi,0.1,0);
T_KJL = TranslatorN3(AUX_KNEE, -KNEE,0);
R_KJL = RotorN3(1,0,0,KJL_xr);
M_KJL = T_KJL*R_KJL;
MKJL = MHJL*M_KJL;
P_KJL = MKJL*e0*(~MKJL);

//AJR
AJR_xr = Slider("AJR xr",-Pi,Pi,0.1,0);
AJR_yr = Slider("AJR yr",-Pi,Pi,0.1,0);
AJR_zr = Slider("AJR zr",-Pi,Pi,0.1,0);
T_AJR = TranslatorN3(-AUX_SHIN, -SHIN,0);
R_AJR = RotorN3(1,0,0,AJR_xr)*RotorN3(0,1,0,AJR_yr)*RotorN3(0,0,1,AJR_zr);
M_AJR = T_AJR*R_AJR;
MAJR = MKJR*M_AJR;
P_AJR = MAJR*e0*(~MAJR);

//AJL
AJL_xr = Slider("AJL xr",-Pi,Pi,0.1,0);
AJL_yr = Slider("AJL yr",-Pi,Pi,0.1,0);
AJL_zr = Slider("AJL zr",-Pi,Pi,0.1,0);
T_AJL = TranslatorN3(AUX_SHIN, -SHIN,0);
R_AJL = RotorN3(1,0,0,AJL_xr)*RotorN3(0,1,0,AJL_yr)*RotorN3(0,0,1,AJL_zr);
M_AJL = T_AJL*R_AJL;
MAJL = MKJL*M_AJL;
P_AJL = MAJL*e0*(~MAJL);

//DRAWING
:White;
:P_LLJ - 1/2*(JOINT_RADIUS)^^2*einf;
:P_UAUX - 1/2*(JOINT_RADIUS)^^2*einf;
:P_LNJ - 1/2*(JOINT_RADIUS)^^2*einf;
:P_SJR - 1/2*(JOINT_RADIUS)^^2*einf;
:P_SJL - 1/2*(JOINT_RADIUS)^^2*einf;
:P_EJR - 1/2*(JOINT_RADIUS)^^2*einf;
:P_EJL - 1/2*(JOINT_RADIUS)^^2*einf;
:P_WR - 1/2*(JOINT_RADIUS)^^2*einf;
:P_WL - 1/2*(JOINT_RADIUS)^^2*einf;
:P_HJR - 1/2*(JOINT_RADIUS)^^2*einf;
:P_HJL - 1/2*(JOINT_RADIUS)^^2*einf;
:P_KJR - 1/2*(JOINT_RADIUS)^^2*einf;
:P_KJL - 1/2*(JOINT_RADIUS)^^2*einf;
:P_AJR - 1/2*(JOINT_RADIUS)^^2*einf;
:P_AJL - 1/2*(JOINT_RADIUS)^^2*einf;

:Yellow;
::Cilindro(P_LLJ,P_UAUX,CILINDER_RADIUS);
::Cilindro(P_UAUX,P_LNJ,CILINDER_RADIUS);
::Cilindro(P_UAUX,P_SJR,CILINDER_RADIUS);
::Cilindro(P_UAUX,P_SJL,CILINDER_RADIUS);
::Cilindro(P_SJR,P_EJR,CILINDER_RADIUS);
::Cilindro(P_SJL,P_EJL,CILINDER_RADIUS);
::Cilindro(P_EJR,P_WR,CILINDER_RADIUS);
::Cilindro(P_EJL,P_WL,CILINDER_RADIUS);
::Cilindro(P_LLJ,P_HJR,CILINDER_RADIUS);
::Cilindro(P_LLJ,P_HJL,CILINDER_RADIUS);
::Cilindro(P_HJR,P_KJR,CILINDER_RADIUS);
::Cilindro(P_HJL,P_KJL,CILINDER_RADIUS);
::Cilindro(P_KJR,P_AJR,CILINDER_RADIUS);
::Cilindro(P_KJL,P_AJL,CILINDER_RADIUS);
//::Cilindro(P_HJR,P_HJL,CILINDER_RADIUS);


:Color(1, 1, 0.588, .9);
Px = MAJR * VecN3(70*scale, 0, 0) * (~MAJR);
Py = MAJR * VecN3(0, 70*scale, 0) * (~MAJR);
Pz = MAJR * VecN3(0, 0, 150*scale) * (~MAJR);
::Cajita(P_AJR, Px, Py, Pz);

Px = MAJL * VecN3(70*scale, 0, 0) * (~MAJL);
Py = MAJL * VecN3(0, 70*scale, 0) * (~MAJL);
Pz = MAJL * VecN3(0, 0, 150*scale) * (~MAJL);
::Cajita(P_AJL, Px, Py, Pz);

Px = MWR * VecN3(50*scale, 0, 0) * (~MWR);
Py = MWR * VecN3(0, 100*scale, 0) * (~MWR);
Pz = MWR * VecN3(0, 0, 50*scale) * (~MWR);
::Cajita(P_WR, Px, Py, Pz);

Px = MWL * VecN3(50*scale, 0, 0) * (~MWL);
Py = MWL * VecN3(0, 100*scale, 0) * (~MWL);
Pz = MWL * VecN3(0, 0, 50*scale) * (~MWL);
::Cajita(P_WL, Px, Py, Pz);

Px = MLNJ * VecN3(200*scale, 0, 0) * (~MLNJ);
Py = MLNJ * VecN3(0, 200*scale, 0) * (~MLNJ);
Pz = MLNJ * VecN3(0, 0, 200*scale) * (~MLNJ);
::Cajita(P_LNJ, Px, Py, Pz);